# LanguageCapo: Language Classification Agent\n\n## Overview\n\n**LanguageCapo** (`model.LanguageCapo`) is a pre-workflow agent that determines whether a user's natural language input should be processed as a **RULE** request or a **CONTENT** request.\n\nIt acts as a **language classifier** that routes users to the appropriate workflow based on their intent.\n\n## Problem It Solves\n\nWhen users submit natural language queries like:\n- \"Show me patterns in episodes\" → Should be RULE flow\n- \"Extract entities from this newsletter\" → Should be CONTENT flow\n\nThe supervisor needs to know which workflow to enter. LanguageCapo makes this determination automatically.\n\n## Architecture\n\n### Pre-Workflow Stage\n\n```\n[User] → \"Show me patterns...\"\n          ↓\n[Frontend] → Envelope(verb=GENERIC, nextAgent=LanguageCapo)\n          ↓\n[Supervisor] → Calls LanguageCapo to determine verb\n          ↓\n[LanguageCapo] → Returns (decision, confidence, reason, verb)\n          ↓\n[Supervisor] → Routes to RULE or CONTENT workflow\n          ↓\n[Workflow] → Enters appropriate decision tree\n```\n\n### Agent Interface\n\n```python\nasync def agent_language_capo(message_body: Dict[str, Any]) -> Tuple[str, float, str, str]:\n    \"\"\"\n    Returns: (decision, confidence, reason, verb)\n    - decision: \"yes\" or \"no\"\n    - confidence: 0.0-1.0\n    - reason: Classification explanation\n    - verb: \"RULE\" or \"CONTENT\"\n    \"\"\"\n```\n\nNote: This is the **only agent** that returns a 4-tuple with the `verb` field.\n\n## Classification Heuristics\n\n### RULE Keywords (Data Query)\n```python\nrule_keywords = [\n    \"show\", \"find\", \"list\", \"get\", \"query\", \"pattern\", \"view\",\n    \"select\", \"where\", \"group\", \"having\", \"order\", \"sql\",\n    \"episodes\", \"guests\", \"organizations\", \"posts\", \"orgs\"\n]\n```\n\n**Examples matching RULE:**\n- \"Show me all patterns in episodes\"\n- \"List guests with their organizations\"\n- \"Find patterns created in 2024\"\n- \"Query episodes with pattern count > 5\"\n\n### CONTENT Keywords (Entity Extraction)\n```python\ncontent_keywords = [\n    \"extract\", \"analyze\", \"parse\", \"read\", \"import\", \"ingest\",\n    \"newsletter\", \"podcast\", \"transcript\", \"article\", \"content\",\n    \"url\", \"link\", \"upload\", \"entities\", \"entity\"\n]\n```\n\n**Examples matching CONTENT:**\n- \"Extract entities from this podcast\"\n- \"Analyze this newsletter for organizations\"\n- \"Parse this transcript for guests\"\n- \"Ingest content from this URL\"\n\n### Scoring Algorithm\n\n1. Count keyword matches in user input\n2. Compare RULE score vs CONTENT score\n3. Determine verb based on winner:\n   - If RULE score > CONTENT score: verb = \"RULE\"\n   - If CONTENT score > RULE score: verb = \"CONTENT\"\n   - If tied: default to \"RULE\"\n\n4. Calculate confidence:\n   - `confidence = min(0.95, 0.5 + (score * 0.1))`\n   - 1 keyword: 60% confidence\n   - 2 keywords: 70% confidence\n   - 3+ keywords: 80%+, capped at 95%\n\n## Message Flow in Supervisor\n\n### Request Stage\n\nFrontend sends request with:\n- `verb: \"GENERIC\"` (placeholder)\n- `nextAgent: \"model.LanguageCapo\"`\n- `messageBody: {\"raw_text\": \"user input\"}`\n\n### Classification Stage\n\n```python\n# In supervisor.process_envelope()\nif env.verb.value == \"GENERIC\" or env.nextAgent == \"model.LanguageCapo\":\n    result = await call_agent(\"model.LanguageCapo\", \"GENERIC\", message_body)\n    decision, confidence, reason, verb_determined = result\n    \n    # Send classification response\n    response = make_response(\n        nextAgent=\"model.Capo\",  # Real workflow starts\n        decision=Decision(decision),\n        confidence=confidence,\n        reason=reason,\n        # messageBody unchanged\n    )\n    await self._send_envelope(response)\n    \n    if decision == \"no\":\n        return  # HITL: user input rejected\n    \n    verb_str = verb_determined\n```\n\n### Routing Stage\n\nAfter classification, supervisor enters appropriate workflow:\n\n```python\n# verb_str is now either \"RULE\" or \"CONTENT\"\ncurrent_agent = \"model.Capo\"  # Real Capo (not LanguageCapo)\n\nwhile True:\n    decision, confidence, reason = await call_agent(current_agent, verb_str, env.messageBody)\n    next_agent = self.workflow_engine.get_next_agent(verb_str, current_agent, decision)\n    # ... continue decision tree walk\n```\n\n## Frontend Integration\n\n### Request Creation\n\n```typescript\nconst request = {\n  type: 'request',\n  verb: 'GENERIC',  // ← Not RULE or CONTENT\n  nextAgent: 'model.LanguageCapo',\n  messageBody: {\n    raw_text: userInput  // Raw user text for classification\n  }\n};\n\nwebsocket.send(JSON.stringify(request));\n```\n\n### Response Handling\n\nFrontend receives classification response:\n\n```typescript\nif (data.type === 'response' && data.nextAgent === 'model.Capo') {\n  // This is the LanguageCapo classification response\n  console.log(`Classified as: ${data.decision}`);\n  console.log(`Confidence: ${data.confidence}`);\n  console.log(`Reason: ${data.reason}`);\n  \n  // Display to user\n  // Then wait for workflow responses (from real Capo and downstream agents)\n}\n```\n\n## Example Conversation Flow\n\n```\nUser (Frontend):        \"Show me patterns in episodes\"\n                        ↓\nWebSocket sends:        {verb: \"GENERIC\", nextAgent: \"model.LanguageCapo\", ...}\n                        ↓\nSupervisor receives:    envelope\n                        ↓\nSupervisor calls:       await call_agent(\"model.LanguageCapo\", ...)\n                        ↓\nLanguageCapo returns:   (\"yes\", 0.80, \"3 RULE keywords detected\", \"RULE\")\n                        ↓\nSupervisor sends:       Response: {decision: \"yes\", nextAgent: \"model.Capo\", confidence: 0.80}\n                        ↓\nFrontend displays:      [YES] (80%) → 3 RULE keywords detected → Next: model.Capo\n                        ↓\nSupervisor continues:   Enter RULE workflow\n                        ↓\nSupervisor calls:       await call_agent(\"model.Capo\", \"RULE\", ...)\n                        ↓\nmodel.Capo returns:     (\"yes\", 0.85, \"Rule syntax valid\", ...)\n                        ↓\nSupervisor sends:       Response: {decision: \"yes\", nextAgent: \"model.verifyRequest\", ...}\n                        ↓\n[... workflow continues ...]\n```\n\n## Future Enhancements\n\n### Real LLM Classification\n\nReplace keyword heuristics with LLM-based classification:\n\n```python\nasync def agent_language_capo(message_body):\n    raw_text = message_body.get(\"raw_text\", \"\")\n    \n    # Call GPT-4o\n    response = await llm.classify(\n        prompt=f\"Is this a data query (RULE) or content extraction (CONTENT)? Input: {raw_text}\"\n    )\n    \n    verb = extract_verb(response)  # RULE or CONTENT\n    confidence = extract_confidence(response)  # 0.0-1.0\n    reason = response.explanation\n    \n    return (\"yes\", confidence, reason, verb)\n```\n\n### Confidence-Based Routing\n\nIf confidence is low (< 0.6), trigger HITL:\n\n```python\nif confidence < 0.6:\n    return (\"no\", confidence, \"Ambiguous intent, requires human clarification\", verb)\n```\n\nFrontend would then ask user:\n- \"I'm unsure if you want a data query or content extraction. Which is it?\"\n\n### Multi-Intent Detection\n\nSupport compound requests:\n- \"Extract entities from the podcast AND show me patterns in episodes\"\n  - Returns: [\"CONTENT\", \"RULE\"] → Execute both workflows\n\n## Testing\n\n### Unit Test\n\n```python\nfrom pitboss.agents import agent_language_capo\n\nresult = await agent_language_capo({\n    \"raw_text\": \"Show me all patterns\"\n})\ndec, conf, reason, verb = result\nassert verb == \"RULE\"\nassert confidence > 0.7\n```\n\n### Integration Test\n\nSee supervisor handling of LanguageCapo:\n- Verify supervisor routes to correct workflow\n- Verify classification response sent to frontend\n- Verify decision tree walks with determined verb\n\n## Key Design Decisions\n\n1. **4-tuple Return**: LanguageCapo returns verb in addition to decision/confidence/reason\n   - This is the **only agent** that determines routing\n   - Normal agents don't need to return verb\n\n2. **GENERIC Verb Placeholder**: Frontend doesn't know verb in advance\n   - Prevents frontend from needing classification logic\n   - Single entry point for all natural language input\n\n3. **Deterministic Classification**: Uses keyword heuristics (not random)\n   - Makes testing reproducible\n   - Ready for real LLM implementation\n\n4. **Response Before Workflow**: Send classification response to frontend\n   - User sees \"interpreted as RULE\" feedback\n   - Improves transparency and debugging\n\n## Edge Cases\n\n### Ambiguous Input\n- \"Extract and show data\"\n- LanguageCapo scores both equally\n- Default to RULE\n- Reason: \"Ambiguous intent, defaulting to RULE workflow\"\n\n### Very Short Input\n- \"patterns\" (1 keyword)\n- Score: 1 RULE keyword\n- Verb: RULE\n- Confidence: 60%\n\n### No Keywords Match\n- \"hello\", \"test\", \"asdf\"\n- Score: 0 vs 0 (tied)\n- Default to RULE\n- Confidence: 55%\n- Reason: \"Ambiguous intent, defaulting to RULE workflow\"\n\n## Summary\n\n**LanguageCapo** solves the **verb classification problem** by:\n1. Accepting raw user input (no verb specified)\n2. Analyzing keywords to determine RULE vs CONTENT intent\n3. Returning verb + confidence + reason\n4. Allowing supervisor to route to correct workflow\n5. Providing transparent feedback to frontend\n\nThis ensures the supervisor **always knows which workflow to enter**, making the message protocol deterministic and user-friendly.\n"}}
